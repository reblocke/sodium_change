<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sodium ΔNa Uncertainty Calculator</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
  </head>
  <body>
    <header class="site-header">
      <h1>Sodium ΔNa Uncertainty Calculator</h1>
      <p class="subtitle">Quantify measurement uncertainty for sodium changes.</p>
    </header>

    <main class="layout">
      <div id="banner" class="banner" style="display: none;"></div>
      <section class="panel">
        <h2>Inputs</h2>
        <div class="field-grid">
          <label>
            Na1 (mmol/L)
            <input id="na1" type="number" step="0.1" value="130" />
          </label>
          <label>
            Method (Na1)
            <select id="method1">
              <option value="central_lab_indirect_ISE">Central lab (indirect ISE)</option>
              <option value="istat_direct_ISE">i-STAT (direct ISE)</option>
            </select>
          </label>
          <label>
            Na2 (mmol/L)
            <input id="na2" type="number" step="0.1" value="133" />
          </label>
          <label>
            Method (Na2)
            <select id="method2">
              <option value="central_lab_indirect_ISE">Central lab (indirect ISE)</option>
              <option value="istat_direct_ISE">i-STAT (direct ISE)</option>
            </select>
          </label>
        </div>

        <div class="field-stack">
          <div>
            <p class="label">Context</p>
            <label class="radio">
              <input type="radio" name="context" value="analytic_repeatability" checked />
              Analytic-only (same specimen)
            </label>
            <label class="radio">
              <input type="radio" name="context" value="sequential_draws" />
              Two sequential draws
            </label>
          </div>
          <label>
            Confidence level
            <select id="ci-level">
              <option value="0.5">50%</option>
              <option value="0.8">80%</option>
              <option value="0.95" selected>95%</option>
            </select>
          </label>
          <label>
            Threshold for |ΔNa| probability (mmol/L)
            <input id="delta-threshold" type="number" step="0.1" value="2" />
          </label>
        </div>

        <button id="calculate" class="primary">Calculate</button>
        <div id="errors" class="messages" role="alert"></div>

        <details class="advanced">
          <summary>Advanced settings (LoA / σ overrides)</summary>
          <p class="hint">
            Enter LoA half-widths for paired measurements. If a σ value is provided, it
            overrides the LoA entry for that row.
          </p>
          <div class="table">
            <div class="table-row table-head">
              <div>Context</div>
              <div>Method</div>
              <div>LoA half-width (mmol/L)</div>
              <div>σ override (mmol/L)</div>
            </div>
            <div class="table-row">
              <div>Analytic repeatability</div>
              <div>Central lab</div>
              <div><input id="loa-analytic_repeatability-central_lab_indirect_ISE" type="number" step="0.1" /></div>
              <div><input id="sigma-analytic_repeatability-central_lab_indirect_ISE" type="number" step="0.01" placeholder="optional" /></div>
            </div>
            <div class="table-row">
              <div>Analytic repeatability</div>
              <div>i-STAT</div>
              <div><input id="loa-analytic_repeatability-istat_direct_ISE" type="number" step="0.1" /></div>
              <div><input id="sigma-analytic_repeatability-istat_direct_ISE" type="number" step="0.01" placeholder="optional" /></div>
            </div>
            <div class="table-row">
              <div>Sequential draws</div>
              <div>Central lab</div>
              <div><input id="loa-sequential_draws-central_lab_indirect_ISE" type="number" step="0.1" /></div>
              <div><input id="sigma-sequential_draws-central_lab_indirect_ISE" type="number" step="0.01" placeholder="optional" /></div>
            </div>
            <div class="table-row">
              <div>Sequential draws</div>
              <div>i-STAT</div>
              <div><input id="loa-sequential_draws-istat_direct_ISE" type="number" step="0.1" /></div>
              <div><input id="sigma-sequential_draws-istat_direct_ISE" type="number" step="0.01" placeholder="optional" /></div>
            </div>
          </div>

          <div class="advanced-actions">
            <button id="reset-defaults" type="button">Reset to defaults</button>
            <button id="export-json" type="button">Export JSON</button>
            <button id="import-json" type="button">Import JSON</button>
          </div>
          <textarea id="params-json" rows="6" placeholder="Paste parameter JSON here."></textarea>
          <div id="params-status" class="messages"></div>
        </details>
      </section>

      <section class="panel">
        <h2>Results</h2>
        <div class="results">
          <p><strong>Observed ΔNa:</strong> <span id="observed-delta">—</span></p>
          <p id="same-sample-row" style="display: none;">
            <strong>P(|ΔNa| ≥ observed | same sample):</strong>
            <span id="same-sample-prob">—</span>
          </p>
          <p id="delta-ci-row">
            <strong>Plausible true ΔNa interval (<span id="ci-level-display">95%</span>):</strong>
            <span id="delta-ci">—</span>
          </p>
          <p id="delta-sd-row"><strong>ΔNa SD:</strong> <span id="delta-sd">—</span></p>
          <p id="delta-gt-zero-row"><strong>P(ΔNa &gt; 0):</strong> <span id="delta-gt-zero">—</span></p>
          <p id="delta-abs-row">
            <strong>P(|ΔNa| &gt; threshold):</strong>
            <span id="delta-abs-threshold">—</span>
          </p>
          <div id="analytic-note" class="note"></div>
        </div>
        <div class="results-grid">
          <div>
            <h3>True Na1</h3>
            <p>Mean: <span id="na1-mean">—</span></p>
            <p>SD: <span id="na1-sd">—</span></p>
            <p>CI: <span id="na1-ci">—</span></p>
          </div>
          <div>
            <h3>True Na2</h3>
            <p>Mean: <span id="na2-mean">—</span></p>
            <p>SD: <span id="na2-sd">—</span></p>
            <p>CI: <span id="na2-ci">—</span></p>
          </div>
        </div>
        <p class="hint">
          Assumptions: independent (uncorrelated) measurement errors, Normal error model, and
          variability parameters that apply to your setting. Results do not account for systematic
          bias, preanalytic artifacts, or physiologic priors.
        </p>
      </section>

      <section class="panel">
        <h2>Distributions</h2>
        <div class="plot-grid">
          <div>
            <h3 id="plot-title-na1">True Na1</h3>
            <canvas id="plot-na1" width="320" height="200"></canvas>
          </div>
          <div>
            <h3 id="plot-title-na2">True Na2</h3>
            <canvas id="plot-na2" width="320" height="200"></canvas>
          </div>
          <div>
            <h3 id="plot-title-delta">True ΔNa</h3>
            <canvas id="plot-delta" width="320" height="200"></canvas>
          </div>
        </div>
      </section>
    </main>

    <section class="disclaimer">
      <p>
        This tool is educational and not medical advice. It assumes independent normal
        measurement errors and uses limits of agreement you provide or edit. It does not
        correct for systematic bias or preanalytic artifacts unless you include them.
      </p>
    </section>

    <noscript>This app requires JavaScript.</noscript>

    <script>
      const STORAGE_KEY = "sodium_uncertainty_params";
      const METHODS = ["central_lab_indirect_ISE", "istat_direct_ISE"];
      const CONTEXTS = ["analytic_repeatability", "sequential_draws"];
      let pyodideReady;
      let computeFromJson;

      const setText = (id, value) => {
        document.getElementById(id).textContent = value;
      };

      const formatNumber = (value, digits = 2) => {
        if (value === null || value === undefined || Number.isNaN(value)) {
          return "—";
        }
        return Number.parseFloat(value).toFixed(digits);
      };

      const showMessages = (id, messages) => {
        const container = document.getElementById(id);
        if (!messages || messages.length === 0) {
          container.textContent = "";
          return;
        }
        container.innerHTML = messages.map((msg) => `<div>${msg}</div>`).join("");
      };

      const showBanner = (message) => {
        const banner = document.getElementById("banner");
        banner.textContent = message;
        banner.style.display = "block";
      };

      const clearBanner = () => {
        const banner = document.getElementById("banner");
        banner.textContent = "";
        banner.style.display = "none";
      };

      const getContextValue = () =>
        document.querySelector("input[name=\"context\"]:checked").value;

      const applyParamsToInputs = (params) => {
        CONTEXTS.forEach((context) => {
          METHODS.forEach((method) => {
            const entry = params.defaults[context][method];
            document.getElementById(`loa-${context}-${method}`).value = entry.loa_half_pair ?? "";
            document.getElementById(`sigma-${context}-${method}`).value = entry.sigma ?? "";
          });
        });
      };

      const collectParamsFromInputs = () => {
        const params = {
          version: 1,
          units: "mmol/L",
          defaults: {
            analytic_repeatability: {},
            sequential_draws: {},
          },
        };
        CONTEXTS.forEach((context) => {
          METHODS.forEach((method) => {
            const loaValue = document.getElementById(`loa-${context}-${method}`).value;
            const sigmaValue = document.getElementById(`sigma-${context}-${method}`).value;
            const entry = { loa_half_pair: loaValue === "" ? null : Number(loaValue) };
            if (sigmaValue !== "") {
              entry.sigma = Number(sigmaValue);
            }
            params.defaults[context][method] = entry;
          });
        });
        return params;
      };

      const loadParams = async () => {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          return JSON.parse(stored);
        }
        const response = await fetch("variability_defaults.json");
        return response.json();
      };

      const saveParams = (params) => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(params));
      };

      const drawCurve = (canvasId, curve, mean, intervals, axisLabel, referenceLine = null) => {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const padding = {
          left: 28,
          right: 16,
          top: 16,
          bottom: 32,
        };
        const xs = curve.x;
        const ys = curve.y;
        const xMin = Math.min(...xs);
        const xMax = Math.max(...xs);
        const xSpan = xMax - xMin || 1;
        const yMax = Math.max(...ys, 0.001);

        const scaleX = (x) =>
          padding.left + ((x - xMin) / xSpan) * (canvas.width - padding.left - padding.right);
        const scaleY = (y) =>
          canvas.height - padding.bottom - (y / yMax) * (canvas.height - padding.top - padding.bottom);

        const axisY = canvas.height - padding.bottom;

        const niceStep = (rawStep) => {
          if (!Number.isFinite(rawStep) || rawStep <= 0) {
            return 1;
          }
          const magnitude = 10 ** Math.floor(Math.log10(rawStep));
          const normalized = rawStep / magnitude;
          let step = 10;
          if (normalized <= 1) {
            step = 1;
          } else if (normalized <= 2) {
            step = 2;
          } else if (normalized <= 5) {
            step = 5;
          }
          return step * magnitude;
        };

        const decimalsForStep = (step) => {
          if (step >= 1) {
            return 0;
          }
          if (step >= 0.1) {
            return 1;
          }
          if (step >= 0.01) {
            return 2;
          }
          return 3;
        };

        const drawAxis = () => {
          const rawStep = (xMax - xMin) / 6;
          const step = niceStep(rawStep);
          const decimals = decimalsForStep(step);
          const start = Math.ceil(xMin / step) * step;
          const ticks = [];
          for (let value = start; value <= xMax + step * 0.5; value += step) {
            ticks.push(value);
          }

          ctx.strokeStyle = "#cbd5f5";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding.left, axisY);
          ctx.lineTo(canvas.width - padding.right, axisY);
          ctx.stroke();

          ctx.fillStyle = "#6b7280";
          ctx.font = "11px system-ui, -apple-system, Segoe UI, sans-serif";
          ticks.forEach((value) => {
            const x = scaleX(value);
            ctx.beginPath();
            ctx.moveTo(x, axisY);
            ctx.lineTo(x, axisY + 4);
            ctx.stroke();
            const labelValue = Math.abs(value) < 1e-6 ? 0 : value;
            const label = labelValue.toFixed(decimals);
            ctx.fillText(label, x - ctx.measureText(label).width / 2, axisY + 16);
          });

          if (axisLabel) {
            ctx.fillStyle = "#111827";
            ctx.font = "12px system-ui, -apple-system, Segoe UI, sans-serif";
            ctx.fillText(
              axisLabel,
              canvas.width / 2 - ctx.measureText(axisLabel).width / 2,
              canvas.height - 4,
            );
          }
        };

        const intervalStyles = [
          { level: 0.99, fill: "rgba(31,111,235,0.08)", stroke: "rgba(31,111,235,0.3)" },
          { level: 0.95, fill: "rgba(31,111,235,0.16)", stroke: "rgba(31,111,235,0.45)" },
          { level: 0.5, fill: "rgba(31,111,235,0.28)", stroke: "rgba(31,111,235,0.6)" },
        ];

        const drawIntervals = () => {
          if (!intervals || intervals.length === 0) {
            return;
          }
          const intervalMap = new Map(intervals.map((entry) => [entry.level, entry]));
          intervalStyles.forEach((style) => {
            const entry = intervalMap.get(style.level);
            if (!entry) {
              return;
            }
            const xLow = scaleX(entry.low);
            const xHigh = scaleX(entry.high);
            ctx.fillStyle = style.fill;
            ctx.strokeStyle = style.stroke;
            ctx.lineWidth = 1;
            if (Math.abs(xHigh - xLow) < 1) {
              ctx.beginPath();
              ctx.moveTo(xLow, padding.top);
              ctx.lineTo(xLow, axisY);
              ctx.stroke();
              return;
            }
            ctx.fillRect(xLow, padding.top, xHigh - xLow, axisY - padding.top);
            ctx.beginPath();
            ctx.moveTo(xLow, padding.top);
            ctx.lineTo(xLow, axisY);
            ctx.moveTo(xHigh, padding.top);
            ctx.lineTo(xHigh, axisY);
            ctx.stroke();
          });
        };

        const drawLegend = () => {
          const legendX = padding.left + 4;
          let legendY = padding.top + 6;
          ctx.font = "11px system-ui, -apple-system, Segoe UI, sans-serif";
          ctx.fillStyle = "#111827";
          intervalStyles.forEach((style) => {
            ctx.fillStyle = style.fill;
            ctx.strokeStyle = style.stroke;
            ctx.lineWidth = 1;
            ctx.fillRect(legendX, legendY - 8, 10, 10);
            ctx.strokeRect(legendX, legendY - 8, 10, 10);
            ctx.fillStyle = "#111827";
            ctx.fillText(`${Math.round(style.level * 100)}%`, legendX + 14, legendY);
            legendY += 14;
          });
        };

        const drawIntervalLabels = () => {
          if (!intervals || intervals.length === 0) {
            return;
          }
          ctx.font = "10px system-ui, -apple-system, Segoe UI, sans-serif";
          ctx.fillStyle = "#111827";
          const sorted = [...intervals].sort((a, b) => b.level - a.level);
          let row = 0;
          sorted.forEach((entry) => {
            const label = `${Math.round(entry.level * 100)}%: ${entry.low.toFixed(2)}–${entry.high.toFixed(2)}`;
            const y = padding.top + 12 + row * 12;
            ctx.fillText(label, canvas.width - padding.right - ctx.measureText(label).width, y);
            row += 1;
          });
        };

        drawIntervals();
        drawAxis();

        ctx.strokeStyle = "#1f6feb";
        ctx.lineWidth = 2;
        ctx.beginPath();
        xs.forEach((x, index) => {
          const y = ys[index];
          if (index === 0) {
            ctx.moveTo(scaleX(x), scaleY(y));
          } else {
            ctx.lineTo(scaleX(x), scaleY(y));
          }
        });
        ctx.stroke();

        const drawLine = (value, color, dashed = false) => {
          ctx.strokeStyle = color;
          ctx.lineWidth = 1.5;
          ctx.setLineDash(dashed ? [4, 4] : []);
          ctx.beginPath();
          ctx.moveTo(scaleX(value), padding.top);
          ctx.lineTo(scaleX(value), axisY);
          ctx.stroke();
          ctx.setLineDash([]);
        };

        drawLine(mean, "#111827");
        if (referenceLine !== null && Number.isFinite(referenceLine)) {
          drawLine(referenceLine, "#ef4444", true);
        }
        drawLegend();
        drawIntervalLabels();
      };

      const updateResults = (result) => {
        const isAnalytic = result.context === "analytic_repeatability";
        const setVisible = (id, visible) => {
          document.getElementById(id).style.display = visible ? "" : "none";
        };

        setText("observed-delta", formatNumber(result.observed_delta, 1));
        setText("ci-level-display", `${Math.round(result.ci_level * 100)}%`);
        setText(
          "delta-ci",
          `[${formatNumber(result.delta_true.ci_low, 1)}, ${formatNumber(
            result.delta_true.ci_high,
            1,
          )}]`,
        );
        setText("delta-sd", formatNumber(result.delta_true.sd, 2));
        setText("delta-gt-zero", formatNumber(result.probabilities.delta_gt_zero, 2));
        setText(
          "delta-abs-threshold",
          formatNumber(result.probabilities.delta_abs_gt_threshold, 2),
        );
        setText("same-sample-prob", formatNumber(result.probabilities.same_sample_p, 3));

        setVisible("same-sample-row", isAnalytic);
        setVisible("delta-ci-row", !isAnalytic);
        setVisible("delta-sd-row", !isAnalytic);
        setVisible("delta-gt-zero-row", !isAnalytic);
        setVisible("delta-abs-row", !isAnalytic);

        setText("na1-mean", formatNumber(result.na1.mean, 1));
        setText("na1-sd", formatNumber(result.na1.sd, 2));
        setText(
          "na1-ci",
          `[${formatNumber(result.na1.ci_low, 1)}, ${formatNumber(result.na1.ci_high, 1)}]`,
        );
        setText("na2-mean", formatNumber(result.na2.mean, 1));
        setText("na2-sd", formatNumber(result.na2.sd, 2));
        setText(
          "na2-ci",
          `[${formatNumber(result.na2.ci_low, 1)}, ${formatNumber(result.na2.ci_high, 1)}]`,
        );

        if (isAnalytic) {
          const note = `Same-specimen null: expected observed ΔNa SD is ${formatNumber(
            result.delta_observed.sd,
            2,
          )}. P(|ΔNa| ≥ observed | same sample) is shown above.`;
          document.getElementById("analytic-note").textContent = note;
        } else {
          document.getElementById("analytic-note").textContent = "";
        }

        if (isAnalytic) {
          document.getElementById("plot-title-na1").textContent = "Na1 likelihood (same-sample)";
          document.getElementById("plot-title-na2").textContent = "Na2 likelihood (same-sample)";
          document.getElementById("plot-title-delta").textContent =
            "Observed ΔNa under same-sample null";

          drawCurve(
            "plot-na1",
            result.curves.na1_obs,
            result.inputs.y1,
            result.intervals?.na1_obs ?? [],
            "mmol/L",
          );
          drawCurve(
            "plot-na2",
            result.curves.na2_obs,
            result.inputs.y2,
            result.intervals?.na2_obs ?? [],
            "mmol/L",
          );
          drawCurve(
            "plot-delta",
            result.curves.delta_observed,
            result.delta_observed.mean,
            result.intervals?.delta_observed ?? [],
            "ΔNa (mmol/L)",
            result.observed_delta,
          );
        } else {
          document.getElementById("plot-title-na1").textContent = "True Na1";
          document.getElementById("plot-title-na2").textContent = "True Na2";
          document.getElementById("plot-title-delta").textContent = "True ΔNa";

          drawCurve(
            "plot-na1",
            result.curves.na1,
            result.na1.mean,
            result.intervals?.na1 ?? [],
            "mmol/L",
          );
          drawCurve(
            "plot-na2",
            result.curves.na2,
            result.na2.mean,
            result.intervals?.na2 ?? [],
            "mmol/L",
          );
          drawCurve(
            "plot-delta",
            result.curves.delta_true,
            result.delta_true.mean,
            result.intervals?.delta_true ?? [],
            "ΔNa (mmol/L)",
          );
        }
      };

      const calculate = async () => {
        showMessages("errors", []);
        clearBanner();
        const params = collectParamsFromInputs();
        const payload = {
          y1: Number(document.getElementById("na1").value),
          y2: Number(document.getElementById("na2").value),
          method1: document.getElementById("method1").value,
          method2: document.getElementById("method2").value,
          context: getContextValue(),
          ci_level: Number(document.getElementById("ci-level").value),
          threshold: Number(document.getElementById("delta-threshold").value),
          params,
        };
        saveParams(params);
        try {
          const resultJson = computeFromJson(JSON.stringify(payload));
          const result = JSON.parse(resultJson);
          const messages = [
            ...result.errors,
            ...(result.warnings || []).map((item) => `Warning: ${item}`),
          ];
          showMessages("errors", messages);
          if (result.errors.length === 0) {
            updateResults(result);
          }
        } catch (error) {
          showMessages("errors", [`Computation error: ${error}`]);
        }
      };

      const init = async () => {
        try {
          pyodideReady = await loadPyodide({
            indexURL: "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/",
          });
          const packageFiles = [
            "sodium_uncertainty/__init__.py",
            "sodium_uncertainty/model.py",
            "sodium_uncertainty/types.py",
            "sodium_uncertainty/defaults.py",
          ];
          pyodideReady.FS.mkdirTree("/home/pyodide/sodium_uncertainty");
          for (const file of packageFiles) {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`Failed to load ${file}: ${response.status}`);
            }
            const content = await response.text();
            pyodideReady.FS.writeFile(`/home/pyodide/${file}`, content);
          }
          pyodideReady.runPython('import sys; sys.path.append("/home/pyodide")');
          const appResponse = await fetch("app.py");
          if (!appResponse.ok) {
            throw new Error(`Failed to load app.py: ${appResponse.status}`);
          }
          const appCode = await appResponse.text();
          pyodideReady.runPython(appCode);
          computeFromJson = pyodideReady.globals.get("compute_from_json");

          const params = await loadParams();
          applyParamsToInputs(params);
          showMessages("params-status", ["Defaults loaded."]);

          document.getElementById("calculate").addEventListener("click", calculate);
          document.getElementById("reset-defaults").addEventListener("click", async () => {
            const freshResponse = await fetch("variability_defaults.json");
            if (!freshResponse.ok) {
              showMessages("params-status", [
                `Defaults load failed: ${freshResponse.status} (variability_defaults.json)`,
              ]);
              return;
            }
            const fresh = await freshResponse.json();
            applyParamsToInputs(fresh);
            saveParams(fresh);
            showMessages("params-status", ["Defaults restored."]);
          });
          document.getElementById("export-json").addEventListener("click", () => {
            const params = collectParamsFromInputs();
            document.getElementById("params-json").value = JSON.stringify(params, null, 2);
            showMessages("params-status", ["Parameters exported to JSON."]);
          });
          document.getElementById("import-json").addEventListener("click", () => {
            const raw = document.getElementById("params-json").value;
            try {
              const parsed = JSON.parse(raw);
              applyParamsToInputs(parsed);
              saveParams(parsed);
              showMessages("params-status", ["Parameters imported."]);
            } catch (error) {
              showMessages("params-status", [`Import failed: ${error}`]);
            }
          });

          calculate();
        } catch (error) {
          showBanner(
            `Initialization failed: ${error}. Check that app.py, variability_defaults.json, and sodium_uncertainty/*.py are reachable on GitHub Pages.`,
          );
        }
      };

      window.addEventListener("error", (event) => {
        showBanner(`Runtime error: ${event.message}`);
      });

      window.addEventListener("unhandledrejection", (event) => {
        showBanner(`Promise error: ${event.reason}`);
      });

      init();
    </script>
  </body>
</html>
